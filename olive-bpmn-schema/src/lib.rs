//! # BPMN Schema
//!
#[cfg(test)]
use olive_internal_macros as olive_im;
use thiserror::Error;

/// Alias for URI
pub type URI = String;
/// Alias for ID
pub type Id = String;
/// Alias for Integer
pub type Integer = num_bigint::BigInt;
/// Alias for Int
pub type Int = i32;

use downcast_rs::{impl_downcast, Downcast};

pub trait DocumentElementContainer: Downcast {
    /// Find an element by ID
    #[allow(unused_variables)]
    fn find_by_id(&self, _id: &str) -> Option<&dyn DocumentElement> {
        None
    }

    /// Find an element by ID return a mutable reference
    #[allow(unused_variables)]
    fn find_by_id_mut(&mut self, _id: &str) -> Option<&mut dyn DocumentElement> {
        None
    }
}
impl_downcast!(DocumentElementContainer);

impl<T> DocumentElementContainer for Vec<T>
where
    T: DocumentElementContainer,
{
    fn find_by_id(&self, id: &str) -> Option<&dyn DocumentElement> {
        for e in self.iter() {
            if let Some(de) = e.find_by_id(id) {
                return Some(de);
            }
        }
        None
    }

    fn find_by_id_mut(&mut self, id: &str) -> Option<&mut dyn DocumentElement> {
        for e in self.iter_mut() {
            if let Some(de) = e.find_by_id_mut(id) {
                return Some(de);
            }
        }
        None
    }
}

impl<T> DocumentElementContainer for Option<T>
where
    T: DocumentElementContainer,
{
    fn find_by_id(&self, id: &str) -> Option<&dyn DocumentElement> {
        match self {
            Some(e) => e.find_by_id(id),
            None => None,
        }
    }

    fn find_by_id_mut(&mut self, id: &str) -> Option<&mut dyn DocumentElement> {
        match self {
            Some(e) => e.find_by_id_mut(id),
            None => None,
        }
    }
}

pub trait Cast<T: ?Sized> {
    fn cast(&self) -> Option<&T> {
        None
    }

    fn cast_mut(&mut self) -> Option<&mut T> {
        None
    }
}

pub trait DocumentElementWithContent: DocumentElement {
    /// Gets document element's content
    fn content(&self) -> &Option<String>;
}

pub trait DocumentElementWithContentMut: DocumentElement {
    /// Gets a mutable reference to document elements' content
    fn content_mut(&mut self) -> &mut Option<String>;
    /// Changes content
    fn set_content(&mut self, content: Option<String>);
}

mod autogenerated;
pub use autogenerated::*;

mod expr;
pub use expr::*;

mod script;
pub use script::*;

mod token;
pub use token::*;

#[derive(Error, Debug)]
pub enum EstablishSequenceFlowError {
    #[error("source.id must be Some")]
    NoSourceId,
    #[error("target.id must be Some")]
    NoTargetId,
    #[error("can't find source of the right type")]
    SourceNotFound,
    #[error("can't find target of the right type")]
    TargetNotFound,
}

impl Process {
    /// Establishes sequence flow between flow identified nodes
    ///
    /// Resulting sequence flow will have `id` as an ID and it will be
    /// added to the matching process.
    // TODO: add support for sub-processes
    pub fn establish_sequence_flow<E: Into<Expr>>(
        &mut self,
        source: &str,
        target: &str,
        id: &str,
        condition_expression: Option<E>,
    ) -> Result<&mut Self, EstablishSequenceFlowError> {
        // The main reason why this method is written in a somewhat convoluted fashion (not saving
        // source and target nodes when we check for their presence) has to do
        // with the need to avoid multiple mutable borrows.

        // check source element presence
        self.find_by_id_mut(source)
            .and_then(|e| Cast::<dyn FlowNodeTypeMut>::cast(e))
            .ok_or(EstablishSequenceFlowError::SourceNotFound)?;

        // check target element presence
        self.find_by_id_mut(target)
            .and_then(|e| Cast::<dyn FlowNodeTypeMut>::cast(e))
            .ok_or(EstablishSequenceFlowError::TargetNotFound)?;

        let sequence_flow = SequenceFlow {
            id: Some(id.to_string()),
            source_ref: source.to_string(),
            target_ref: target.to_string(),
            condition_expression: condition_expression.map(|e| e.into().into()),
            ..SequenceFlow::default()
        };

        // add sequence flow
        self.flow_elements_mut()
            .push(FlowElement::SequenceFlow(sequence_flow));

        // add outgoing
        let source_node = self
            .find_by_id_mut(source)
            .and_then(|e| Cast::<dyn FlowNodeTypeMut>::cast_mut(e))
            .unwrap();

        source_node.outgoings_mut().push(id.into());

        // add incoming
        let target_node = self
            .find_by_id_mut(target)
            .and_then(|e| Cast::<dyn FlowNodeTypeMut>::cast_mut(e))
            .unwrap();
        target_node.incomings_mut().push(id.into());

        Ok(self)
    }
}

#[cfg(test)]
#[olive_im::test]
fn establishing_sequence_flow_in_process() {
    let mut process = Process {
        id: Some("process1".to_string()),
        flow_elements: vec![
            FlowElement::StartEvent(StartEvent {
                id: Some("start".to_string()),
                ..Default::default()
            }),
            FlowElement::EndEvent(EndEvent {
                id: Some("end".to_string()),
                ..Default::default()
            }),
        ],
        ..Default::default()
    };

    process
        .establish_sequence_flow(
            "start",
            "end",
            "test",
            Some(FormalExpression {
                content: Some("condition".into()),
                ..Default::default()
            }),
        )
        .unwrap();

    let seq_flow = process
        .find_by_id("test")
        .unwrap()
        .downcast_ref::<SequenceFlow>()
        .unwrap();
    assert_eq!(seq_flow.id(), &Some("test".to_string()));
    assert_eq!(seq_flow.source_ref(), "start");
    assert_eq!(seq_flow.target_ref(), "end");

    let expr = seq_flow.condition_expression().as_ref().unwrap();
    assert!(
        matches!(expr, SequenceFlowConditionExpression(Expr::FormalExpression(FormalExpression { content, ..}))
            if content.as_ref().unwrap() == "condition")
    );

    let start = Cast::<dyn FlowNodeType>::cast(process.find_by_id("start").unwrap()).unwrap();
    assert_eq!(start.outgoings(), &vec!["test".to_string()]);

    let end = Cast::<dyn FlowNodeType>::cast(process.find_by_id("end").unwrap()).unwrap();
    assert_eq!(end.incomings(), &vec!["test".to_string()]);
}
